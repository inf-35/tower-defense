extends Node
class_name GlobalEventService

# this service helps manage and centralise checks for global effects/events
# it is initialised and supervised by the Player singleton

# structure: Dictionary[Schedule, Dictionary[EventType, Array[EffectInstance]]]
var _global_effects: Dictionary[int, Dictionary] = {}

# we keep a separate list of active instances for easier management/debugging
var _active_instances: Array[EffectInstance] = []

func initialise_event_bus(event_bus_signal: Signal) -> void:
	# connect to the Player's global event bus
	if not event_bus_signal.is_connected(_handle_event):
		event_bus_signal.connect(_handle_event)

# registers a new global effect from a prototype
# returns the created instance so it can be stored or modified if necessary
func register_effect(prototype: EffectPrototype) -> EffectInstance:
	var instance: EffectInstance = prototype.create_instance()

	instance.attach_global()
	var schedule: int = prototype.schedule
	
	# initialize dictionary path if missing
	if not _global_effects.has(schedule):
		_global_effects[schedule] = {}
	
	# sort the instance into buckets based on the events it listens to
	for event_type: GameEvent.EventType in instance.event_hooks:
		if not _global_effects[schedule].has(event_type):
			_global_effects[schedule][event_type] = [] as Array[EffectInstance]
			
		_global_effects[schedule][event_type].append(instance)
	
	_active_instances.append(instance)
	return instance

# removes a specific effect instance.
func deregister_effect(instance: EffectInstance) -> void:
	if not _active_instances.has(instance):
		return
	
	# trigger the detach handler logic
	instance.detach()
	
	# remove from the lookup buckets
	var schedule: int = instance.effect_prototype.schedule
	
	# we rely on the instance's own hooks to find where we put it
	for event_type: GameEvent.EventType in instance.event_hooks:
		if _global_effects.has(schedule) and _global_effects[schedule].has(event_type):
			_global_effects[schedule][event_type].erase(instance)

	# remove from active list
	_active_instances.erase(instance)

# removes all effects generated by a specific prototype
func remove_effect_by_prototype(prototype: EffectPrototype) -> void:
	# iterate backwards to safely remove while looping
	for i: int in range(_active_instances.size() - 1, -1, -1):
		var instance: EffectInstance = _active_instances[i]
		if instance.effect_prototype == prototype:
			deregister_effect(instance)

func _handle_event(_unit: Unit, game_event: GameEvent) -> void:
	var event_type: GameEvent.EventType = game_event.event_type
	
	# iterate through schedules in deterministic order (Multiplicative -> Additive -> Reactive)
	for schedule: int in EffectPrototype.Schedule.values():
		if not _global_effects.has(schedule):
			continue
		
		var global_effects_of_schedule: Dictionary = _global_effects[schedule]
		
		# if no global effects care about this specific event type, skip
		if not global_effects_of_schedule.has(event_type):
			continue
		
		var effects_of_type: Array[EffectInstance] = global_effects_of_schedule[event_type]
		
		# iterate through global effects
		for global_effect: EffectInstance in effects_of_type:
			global_effect.handle_event_unfiltered(game_event)
