extends Node2D
class_name TerrainRenderer

# config
@export var cell_size: int = 10 # must match island cell_size
@export var max_gradient_depth: float = 5.0
@export var show_debug_texture: bool = false

@export var paint_color: Color
@export var wash_color: Color

# visual components
var _terrain_rect: ColorRect
var _bg_rect: ColorRect
var _grid_image: Image
var _grid_texture: ImageTexture
var _grid_data: Dictionary = {} # stores Vector2i -> bool (is_land)

# bounds management
# we track the top-left coordinate of the current image grid
var _min_coord: Vector2i = Vector2i.ZERO
var _size_cells: Vector2i = Vector2i(1, 1)

func _ready() -> void:
	_setup_visuals()
	
	if show_debug_texture:
		_create_debug_view()

func _create_debug_view() -> void:
	var dr = TextureRect.new()
	dr.texture = _grid_texture
	dr.texture_filter = CanvasItem.TEXTURE_FILTER_NEAREST
	dr.scale = Vector2(8, 8)
	dr.position = Vector2(20, 20)
	var c = CanvasLayer.new()
	c.add_child(dr)
	add_child(c)

func _setup_visuals() -> void:
	# initialize with a small empty grid
	_grid_image = Image.create(1, 1, false, Image.FORMAT_L8)
	_grid_texture = ImageTexture.create_from_image(_grid_image)
	
	_terrain_rect = ColorRect.new()
	_terrain_rect.texture_repeat = CanvasItem.TEXTURE_REPEAT_ENABLED
	
	_bg_rect = ColorRect.new()
	_bg_rect.color = Color(1.0, 0.976, 0.941, 1.0)
	_bg_rect.mouse_filter = Control.MOUSE_FILTER_IGNORE
	_bg_rect.size = Vector2(10000,10000)
	_bg_rect.position = Vector2(-5000,-5000)
	add_child(_bg_rect)
	
	var mat := ShaderMaterial.new()
	mat.shader = preload("res://shaders/watercolor_terrain.gdshader")
	
	# noise setup
	var noise := FastNoiseLite.new()
	noise.frequency = 0.01
	var noise_tex := NoiseTexture2D.new()
	noise_tex.width = 512
	noise_tex.height = 512
	noise_tex.noise = noise
	noise_tex.seamless = true
	
	var watercolor_tex: NoiseTexture2D = noise_tex.duplicate_deep(Resource.DeepDuplicateMode.DEEP_DUPLICATE_ALL)
	watercolor_tex.noise.frequency = 0.005
	
	mat.set_shader_parameter("grid_data_texture", _grid_texture)
	mat.set_shader_parameter("distortion_texture", noise_tex)
	mat.set_shader_parameter("noise_texture", watercolor_tex)
	mat.set_shader_parameter("paint_color", paint_color)
	mat.set_shader_parameter("wash_color", wash_color)
	
	# placeholder paper (replace with load("res://...") if you have one)
	var paper_img = Image.create(64, 64, false, Image.FORMAT_RGBA8)
	paper_img.fill(Color(0.95, 0.95, 0.92, 1.0))
	var paper_tex = ImageTexture.create_from_image(paper_img)
	mat.set_shader_parameter("paper_texture", paper_tex)
	
	_terrain_rect.material = mat
	_terrain_rect.mouse_filter = Control.MOUSE_FILTER_IGNORE
	add_child(_terrain_rect)
	_update_rect_transform()

# --- public api ---

# accepts a list of tiles to add/remove to minimize resize operations
# changes: dictionary of { Vector2i cell: bool is_land }
func apply_terrain_changes(changes: Dictionary) -> void:
	if changes.is_empty():
		return
	var needs_resize := false
	var new_min := _min_coord
	var new_max := _min_coord + _size_cells - Vector2i.ONE
	
	# 1. update logic and calculate new bounds
	for cell: Vector2i in changes:
		var is_land: bool = changes[cell]
		
		if is_land:
			_grid_data[cell] = true
			# expand bounds if necessary
			if _grid_data.size() == 1: # first tile
				new_min = cell
				new_max = cell
			else:
				new_min.x = min(new_min.x, cell.x)
				new_min.y = min(new_min.y, cell.y)
				new_max.x = max(new_max.x, cell.x)
				new_max.y = max(new_max.y, cell.y)
		else:
			_grid_data.erase(cell)
			# note: we don't shrink bounds automatically as it's expensive 
			# and islands usually grow. shrinking is optional optimization.

	# add padding to bounds for the gradient to fade out
	var padding = int(max_gradient_depth) + 2
	new_min -= Vector2i(padding, padding)
	new_max += Vector2i(padding, padding)
	
	# check if we need to resize image
	var current_max = _min_coord + _size_cells
	if new_min.x < _min_coord.x or new_min.y < _min_coord.y or new_max.x >= current_max.x or new_max.y >= current_max.y:
		_resize_grid(new_min, new_max - new_min + Vector2i.ONE)
	
	# 2. recalculate distance field
	_update_distance_field()

# --- internal logic ---

func _resize_grid(new_origin: Vector2i, new_size: Vector2i) -> void:
	# safeguard against massive accidental sizes
	if new_size.x > 4096 or new_size.y > 4096:
		push_warning("terrain grid growing very large: ", new_size)
	
	# create new blank image
	var new_img = Image.create(new_size.x, new_size.y, false, Image.FORMAT_L8)
	
	# update state
	_grid_image = new_img
	_min_coord = new_origin
	_size_cells = new_size
	
	# update visual rect
	_update_rect_transform()

func _update_rect_transform() -> void:
	# place the rect in the world
	_terrain_rect.position = Vector2(_min_coord * cell_size)
	_terrain_rect.size = Vector2(_size_cells * cell_size)
	
	# pass world info to shader
	var mat = _terrain_rect.material as ShaderMaterial
	mat.set_shader_parameter("region_pixel_offset", _terrain_rect.position)
	mat.set_shader_parameter("region_pixel_size", _terrain_rect.size)

func _update_distance_field() -> void:
	# standard bfs logic, but offset by _min_coord
	_grid_image.fill(Color.BLACK) # clear image
	
	var dist_map := {} # local coords -> distance
	var queue: Array[Vector2i] = []
	
	# initialize bfs seeds (land tiles)
	# we do multi-source bfs from land outwards? 
	# actually for watercolor gradient usually we want dist FROM water INTO land.
	# so water is 0, land starts at 1.
	
	# simpler approach: fill image with 0. 
	# set all land pixels to -1 (unvisited).
	# find all land pixels next to water -> queue.
	
	# 1. map global _grid_data to local image pixels
	for global_pos in _grid_data:
		var local_pos = global_pos - _min_coord
		if local_pos.x >= 0 and local_pos.y >= 0 and local_pos.x < _size_cells.x and local_pos.y < _size_cells.y:
			# temporary marker for land
			_grid_image.set_pixelv(local_pos, Color(1, 1, 1, 1)) 
			
	# 2. build bfs for gradient
	# this is computationally heavy for huge maps.
	# optimization: only iterate pixels inside the dirty rect?
	# for now, we do full rebuild for correctness.
	
	var local_queue: Array[Vector2i] = []
	var visited := {}
	
	# find boundary: land cells adjacent to empty/water
	# since _grid_image is padded, we can iterate internal area
	for x in range(1, _size_cells.x - 1):
		for y in range(1, _size_cells.y - 1):
			if _grid_image.get_pixel(x, y).r > 0.5: # is land
				var is_coast = false
				# check 4 neighbors for water (black)
				if _grid_image.get_pixel(x+1, y).r < 0.5: is_coast = true
				elif _grid_image.get_pixel(x-1, y).r < 0.5: is_coast = true
				elif _grid_image.get_pixel(x, y+1).r < 0.5: is_coast = true
				elif _grid_image.get_pixel(x, y-1).r < 0.5: is_coast = true
				
				if is_coast:
					local_queue.append(Vector2i(x, y))
					visited[Vector2i(x, y)] = 1.0 # distance 1
	
	# bfs
	var head = 0
	while head < local_queue.size():
		var curr = local_queue[head]
		head += 1
		var dist = visited[curr]
			
		var neighbors = [Vector2i(0,1), Vector2i(0,-1), Vector2i(1,0), Vector2i(-1,0)]
		for n in neighbors:
			var next = curr + n
			# if it is land and we haven't assigned a distance yet
			# check bounds
			if next.x >= 0 and next.y >= 0 and next.x < _size_cells.x and next.y < _size_cells.y:
				# check if it is land (we marked land as white earlier)
				# and not visited (visited dict check)
				if _grid_image.get_pixelv(next).r > 0.5 and not visited.has(next):
					visited[next] = dist + 1.0
					local_queue.append(next)
	
	# 3. write final values to image
	# we need to clear the simple boolean mask we made in step 1 and replace with gradient
	_grid_image.fill(Color.BLACK)
	
	for local_pos in visited:
		var d = visited[local_pos]
		var norm = d / max_gradient_depth
		norm = clamp(norm, 0.0, 1.0)
		_grid_image.set_pixelv(local_pos, Color(norm, norm, norm))
		
	_grid_texture.set_image(_grid_image)
